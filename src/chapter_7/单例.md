#### 单例模式
> 单例模式定义：确保某一个类只有一个实例，而且自行实例化
>并向整个系统提供这个实例。

* 单例模式的优点：  
1.由于单例模式再内存中只有实例，减少了内存开支，特别是一个
对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，
单例模式的优势就非常明显。  
2.由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个
对象的常胜需要比较多的资源时，如读取配置、产生其他依赖对象时，
则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存
的方式来解决（在Java EE中采用单例模式时需要注意JVM垃圾回收机制）  
3.单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有
一个实例存在在内存中，避免对同一个资源文件的同时写操作。  
4.单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以
设计一个单例类，负责所有数据表的映射处理。
* 单例模式的缺点  
1. 单例模式一般没有接口，扩展很困难，如要扩展，除了修改代码基本上
没有第二种途径可以实现。单例模式为什么不能增加接口呢？因为接口对
单例模式是没有任何意义的，它要求"自定实例化"，并且提供单一实例、
接口或抽象类是不可能被实例化的。当然，在特殊情况有一个对象，如果出现
多个对象就会出现"不良反应"，可以采用单例模式。


* 线程不安全的单例（懒汉式）
``` java
public class Singleton {
    private static Singleton singleton = null;

    private Singleton(){

    }

    public static Singleton getSingleton(){
        if (singleton == null){
            singleton = new Singleton();
        }
        return singleton;
    }
}
```
> 该单例模式在低并发的情况下尚不会出现问题，若系统压力增大，并发量增加时则
>可能在内存中出现多个实例，破坏了最初的预期。出现这种情况是因为如一个线程A
>执行到singleton = new Singleton(),但是还没有获得对象（对象初始化
>需要时间的），第二个线程B也在执行，执行到（singleton == null）判断，
>那么线程B获得判断条件也是为TRUE，于是继续运行下去，线程A获得了一个对象，
>线程B也获得了一个对象，于是内存中就出现了两个对象。
* 解决线程不安全的方法有很多，可以在getSington方法钱加synchronized关键字，
也可以在getSingleton方法内增加synchronized来实现，但都不是最优秀的单例模式，

